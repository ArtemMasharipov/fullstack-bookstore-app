# Миграция с Vue CLI на Vite

В этом документе описаны шаги, выполненные для миграции проекта BookStore с Vue CLI на Vite.

## Причины миграции

- **Скорость разработки**: Vite предлагает гораздо более быструю разработку благодаря встроенному DEV-серверу на основе ESM
- **Скорость сборки**: Оптимизированная сборка для продакшна
- **Современный подход**: Использование нативных ESM модулей вместо связки webpack
- **Меньше конфигурации**: Более простая настройка и улучшенный опыт разработки

## Выполненные изменения

### 1. Установка пакетов Vite
```bash
npm install --save-dev vite @vitejs/plugin-vue
```

### 2. Создание файла конфигурации Vite
Создан файл `vite.config.js` со следующими настройками:
- Настройки псевдонимов путей для `@`
- Настройки сборки для production с оптимизацией
- Проксирование API запросов
- Разделение зависимостей на чанки

### 3. Обновление package.json
- Добавлен `"type": "module"` для поддержки ESM
- Обновлены скрипты сборки:
  - `dev`: запуск сервера разработки Vite
  - `build`: сборка для продакшн с Vite
  - `preview`: предварительный просмотр собранного приложения

### 4. Перемещение index.html
- Файл перемещен из папки `/public` в корень проекта
- Обновлены ссылки на ресурсы для работы с Vite
- Добавлен тег `<script type="module">` для загрузки точки входа

### 5. Настройка переменных окружения
- Созданы файлы `.env`, `.env.development` и `.env.production`
- Обновлен формат переменных с `process.env.VUE_APP_*` на `import.meta.env.VITE_*`

### 6. Обновление импортов
- Исправлены случаи использования `require()` на ESM-совместимые импорты
- Обновлен импорт статических ресурсов

### 7. Удаление ненужных файлов
- Удалены файлы конфигурации Vue CLI (`vue.config.js`, `babel.config.js`)
- Обновлены файлы конфигурации ESLint для совместимости с Vite

## Как запустить проект

Для запуска проекта с новой системой сборки Vite:

```bash
# Установка зависимостей
npm install

# Запуск сервера разработки
npm run dev

# Сборка для продакшн
npm run build

# Предварительный просмотр сборки
npm run preview
```

## Полезные ссылки
- [Документация Vite](https://vitejs.dev/)
- [Vite плагин для Vue](https://github.com/vitejs/vite-plugin-vue)
- [Руководство по миграции с Vue CLI на Vite](https://vueschool.io/articles/vuejs-tutorials/how-to-migrate-from-vue-cli-to-vite/)

# Миграция с Vuex на Pinia

## Обзор

В этом проекте мы выполнили миграцию с Vuex на Pinia для управления состоянием приложения. Pinia - это современная библиотека управления состоянием для Vue.js, которая предоставляет более простой API, лучшую поддержку TypeScript и улучшенное взаимодействие с инструментами разработчика.

Миграция выполнена с использованием только Options API для поддержания консистентности с существующим кодом.

## Основные изменения

1. **Установка Pinia**
   ```bash
   npm install pinia
   ```

2. **Обновление точки входа (main.js)**
   - Импортирование и использование Pinia вместо Vuex
   - Инициализация состояния авторизации до монтирования приложения

3. **Создание хранилищ Pinia**
   - Созданы отдельные хранилища для каждого модуля:
     - `auth.js` - управление авторизацией и пользователями
     - `cart.js` - управление корзиной покупок
     - `books.js` - управление книгами
     - `authors.js` - управление авторами
     - `users.js` - управление пользователями
     - `orders.js` - управление заказами

4. **Вспомогательные утилиты**
   - Создана новая версия `stateHelpers.js` для Pinia вместо Vuex

5. **Обновление guard авторизации**
   - Обновлен `authGuard.js` для работы с хранилищем Pinia

6. **Обновление компонентов**
   - В компонентах произведены следующие изменения:
     - Замена хелперов Vuex (mapGetters, mapActions) на прямой доступ к хранилищам Pinia через computed свойства
     - Использование computed-геттера для доступа к хранилищу Pinia в компонентах
     - Прямое обращение к действиям и состоянию хранилищ через this.storeInstance

## Структура хранилищ Pinia

Хранилище Pinia имеет следующую структуру:

```js
import { defineStore } from 'pinia'

export const useMyStore = defineStore('myStore', {
  // состояние (было state в Vuex)
  state: () => ({
    // свойства
  }),
  
  // геттеры (те же, что и в Vuex)
  getters: {
    // геттеры
  },
  
  // действия (объединяют actions и mutations из Vuex)
  actions: {
    // действия
  }
})
```

## Преимущества Pinia над Vuex

1. **Более простое API**: не нужно разделять мутации и действия, все изменения состояния выполняются в действиях.
2. **Лучшая поддержка TypeScript**: встроенная типизация без дополнительных плагинов.
3. **Более модульная организация**: не нужны пространства имен.
4. **Прямой доступ к хранилищу**: импортирование хранилища и прямой доступ к его свойствам.
5. **Композиция хранилищ**: возможность использовать одно хранилище внутри другого.

## Подход к использованию Pinia с Options API

В нашем проекте мы используем Pinia с Options API по следующей схеме:

```vue
<script>
import { useMyStore } from '@/stores'

export default {
  computed: {
    // Создаем геттер для хранилища
    myStore() {
      return useMyStore()
    },
    // Удобные геттеры для доступа к состоянию из шаблона
    someValue() {
      return this.myStore.someValue
    }
  },
  methods: {
    someMethod() {
      // Вызываем действие хранилища
      this.myStore.someAction()
    }
  }
}
</script>
```

### Преимущества данного подхода:

1. **Консистентность с Options API**: вся кодовая база использует один стиль API.
2. **Лаконичность**: минимальный код для доступа к хранилищу.
3. **Читаемость**: ясно откуда берутся данные и какие действия выполняются.
4. **Производительность**: хранилище инициализируется через computed, что обеспечивает кэширование и реактивность.

### Ключевые отличия от Vuex с Options API:

1. Вместо `...mapGetters` и `...mapActions` используем прямые вычисляемые свойства.
2. Нет необходимости указывать пространства имен модулей.
3. Доступ к действиям и состоянию через единый экземпляр хранилища.

## Пример мигрированного компонента

```vue
<!-- Vuex (до) -->
<script>
import { mapGetters, mapActions } from 'vuex'

export default {
  computed: {
    ...mapGetters('auth', ['isAuthenticated', 'currentUser'])
  },
  methods: {
    ...mapActions('auth', ['login', 'logout'])
  }
}
</script>

<!-- Pinia (после) -->
<script>
import { useAuthStore } from '@/stores'

export default {
  computed: {
    authStore() {
      return useAuthStore()
    },
    isAuthenticated() {
      return this.authStore.isAuthenticated
    },
    currentUser() {
      return this.authStore.currentUser
    }
  },
  methods: {
    login(credentials) {
      return this.authStore.login(credentials)
    },
    logout() {
      return this.authStore.logout()
    }
  }
}
</script>
```